{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Thunder speech A Hackable speech recognition library. Note This project has been set up using PyScaffold 3.3. For details and usage information on PyScaffold see https://pyscaffold.org/.","title":"Home"},{"location":"#thunder-speech","text":"A Hackable speech recognition library.","title":"Thunder speech"},{"location":"#note","text":"This project has been set up using PyScaffold 3.3. For details and usage information on PyScaffold see https://pyscaffold.org/.","title":"Note"},{"location":"api/Quartznet/blocks/","text":"Basic building blocks to create the Quartznet model InitMode Weight init methods. Used by init_weights . Note Possible values are xavier_uniform , xavier_normal , kaiming_uniform and kaiming_normal QuartznetBlock __init__ ( self , inplanes , planes , repeat = 5 , kernel_size = [ 11 ], stride = [ 1 ], dilation = [ 1 ], dropout = 0.0 , residual = True , separable = False ) special Quartznet block. This is a refactoring of the Jasperblock present on the NeMo toolkit, but simplified to only support the new quartznet model. Biggest change is that dense residual used on Jasper is not supported here, and masked convolutions were also removed. Parameters: Name Type Description Default inplanes int Number of input planes required planes int Number of output planes required repeat int Repetitions inside block. 5 kernel_size List[int] Kernel size. [11] stride List[int] Stride of each repetition. [1] dilation List[int] Dilation of each repetition. [1] dropout float Dropout used before each activation. 0.0 residual bool Controls the use of residual connection. True separable bool Controls the use of separable convolutions. False Source code in thunder/quartznet/blocks.py def __init__ ( self , inplanes : int , planes : int , repeat : int = 5 , kernel_size : List [ int ] = [ 11 ], stride : List [ int ] = [ 1 ], dilation : List [ int ] = [ 1 ], dropout : float = 0.0 , residual : bool = True , separable : bool = False , ): \"\"\"Quartznet block. This is a refactoring of the Jasperblock present on the NeMo toolkit, but simplified to only support the new quartznet model. Biggest change is that dense residual used on Jasper is not supported here, and masked convolutions were also removed. Args: inplanes : Number of input planes planes : Number of output planes repeat : Repetitions inside block. kernel_size : Kernel size. stride : Stride of each repetition. dilation : Dilation of each repetition. dropout : Dropout used before each activation. residual : Controls the use of residual connection. separable : Controls the use of separable convolutions. \"\"\" super () . __init__ () padding_val = get_same_padding ( kernel_size [ 0 ], stride [ 0 ], dilation [ 0 ]) inplanes_loop = inplanes conv = [] for _ in range ( repeat - 1 ): conv . extend ( self . _get_conv_bn_layer ( inplanes_loop , planes , kernel_size = kernel_size , stride = stride , dilation = dilation , padding = padding_val , separable = separable , bias = False , ) ) conv . extend ( self . _get_act_dropout_layer ( drop_prob = dropout )) inplanes_loop = planes conv . extend ( self . _get_conv_bn_layer ( inplanes_loop , planes , kernel_size = kernel_size , stride = stride , dilation = dilation , padding = padding_val , separable = separable , bias = False , ) ) self . mconv = nn . Sequential ( * conv ) if residual : stride_residual = stride if stride [ 0 ] == 1 else stride [ 0 ] ** repeat self . res = nn . Sequential ( * self . _get_conv_bn_layer ( inplanes , planes , kernel_size = 1 , stride = stride_residual , bias = False , ) ) else : self . res = None self . mout = nn . Sequential ( * self . _get_act_dropout_layer ( drop_prob = dropout )) forward ( self , x ) Parameters: Name Type Description Default x Tensor Tensor of shape (batch, features, time) where #features == inplanes required Returns: Type Description Tensor Result of applying the block on the input Source code in thunder/quartznet/blocks.py def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, features, time) where #features == inplanes Returns: Result of applying the block on the input \"\"\" # compute forward convolutions out = self . mconv ( x ) # compute the residuals if self . res is not None : res_out = self . res ( x ) out = out + res_out # compute the output out = self . mout ( out ) return out body ( filters , kernel_size , repeat_blocks = 1 ) Creates the body of the Quartznet model. That is the middle part. Parameters: Name Type Description Default filters List[int] List of filters inside each block in the body. required kernel_size List[int] Corresponding list of kernel sizes for each block. Should have the same length as the first argument. required repeat_blocks int Number of repetitions of each block inside the body. 1 Returns: Type Description List[thunder.quartznet.blocks.QuartznetBlock] List of layers that form the body of the network. Source code in thunder/quartznet/blocks.py def body ( filters : List [ int ], kernel_size : List [ int ], repeat_blocks : int = 1 ) -> List [ QuartznetBlock ]: \"\"\"Creates the body of the Quartznet model. That is the middle part. Args: filters : List of filters inside each block in the body. kernel_size : Corresponding list of kernel sizes for each block. Should have the same length as the first argument. repeat_blocks : Number of repetitions of each block inside the body. Returns: List of layers that form the body of the network. \"\"\" layers = [] f_in = 256 for f , k in zip ( filters , kernel_size ): for _ in range ( repeat_blocks ): layers . append ( QuartznetBlock ( f_in , f , kernel_size = [ k ], separable = True )) f_in = f layers . extend ( [ QuartznetBlock ( f_in , 512 , repeat = 1 , dilation = [ 2 ], kernel_size = [ 87 ], residual = False , separable = True , ), QuartznetBlock ( 512 , 1024 , repeat = 1 , kernel_size = [ 1 ], residual = False , separable = False ), ] ) return layers get_same_padding ( kernel_size , stride , dilation ) Calculates the padding size to obtain same padding. Same padding means that the output will have the shape input_shape / stride. That means, for stride = 1 the output shape is the same as the input, and stride = 2 gives an output that is half of the input shape. Parameters: Name Type Description Default kernel_size int convolution kernel size. Only tested to be correct with odd values. required stride int convolution stride required dilation int convolution dilation required Exceptions: Type Description ValueError Only stride or dilation may be greater than 1 Returns: Type Description int padding value to obtain same padding. Source code in thunder/quartznet/blocks.py def get_same_padding ( kernel_size : int , stride : int , dilation : int ) -> int : \"\"\"Calculates the padding size to obtain same padding. Same padding means that the output will have the shape input_shape / stride. That means, for stride = 1 the output shape is the same as the input, and stride = 2 gives an output that is half of the input shape. Args: kernel_size : convolution kernel size. Only tested to be correct with odd values. stride : convolution stride dilation : convolution dilation Raises: ValueError: Only stride or dilation may be greater than 1 Returns: padding value to obtain same padding. \"\"\" if stride > 1 and dilation > 1 : raise ValueError ( \"Only stride OR dilation may be greater than 1\" ) if dilation > 1 : return ( dilation * ( kernel_size - 1 ) + 1 ) // 2 return kernel_size // 2 init_weights ( m , mode =< InitMode . xavier_uniform : 'xavier_uniform' > ) Initialize Linear, MaskedConv1d/Conv1d or BatchNorm1d weights. There's no return, the operation occurs inplace. Parameters: Name Type Description Default m Module The layer to be initialized required mode InitMode Weight initialization mode. Only applicable to linear and conv layers. <InitMode.xavier_uniform: 'xavier_uniform'> Exceptions: Type Description ValueError Raised when the initial mode is not one of the possible options. Source code in thunder/quartznet/blocks.py def init_weights ( m : nn . Module , mode : InitMode = InitMode . xavier_uniform ): \"\"\"Initialize Linear, MaskedConv1d/Conv1d or BatchNorm1d weights. There's no return, the operation occurs inplace. Args: m: The layer to be initialized mode: Weight initialization mode. Only applicable to linear and conv layers. Raises: ValueError: Raised when the initial mode is not one of the possible options. \"\"\" if isinstance ( m , ( nn . Conv1d , nn . Linear )): if mode == InitMode . xavier_uniform : nn . init . xavier_uniform_ ( m . weight , gain = 1.0 ) elif mode == InitMode . xavier_normal : nn . init . xavier_normal_ ( m . weight , gain = 1.0 ) elif mode == InitMode . kaiming_uniform : nn . init . kaiming_uniform_ ( m . weight , nonlinearity = \"relu\" ) elif mode == InitMode . kaiming_normal : nn . init . kaiming_normal_ ( m . weight , nonlinearity = \"relu\" ) else : raise ValueError ( \"Unknown Initialization mode: {0} \" . format ( mode )) elif isinstance ( m , nn . BatchNorm1d ): if m . track_running_stats : m . running_mean . zero_ () m . running_var . fill_ ( 1 ) m . num_batches_tracked . zero_ () if m . affine : nn . init . ones_ ( m . weight ) nn . init . zeros_ ( m . bias ) stem ( feat_in ) Creates the Quartznet stem. That is the first block of the model, that process the input directly. Parameters: Name Type Description Default feat_in int Number of input features required Returns: Type Description QuartznetBlock Quartznet stem block Source code in thunder/quartznet/blocks.py def stem ( feat_in : int ) -> QuartznetBlock : \"\"\"Creates the Quartznet stem. That is the first block of the model, that process the input directly. Args: feat_in : Number of input features Returns: Quartznet stem block \"\"\" return QuartznetBlock ( feat_in , 256 , repeat = 1 , kernel_size = [ 33 ], residual = False , separable = True )","title":"Blocks"},{"location":"api/Quartznet/blocks/#thunder.quartznet.blocks.InitMode","text":"Weight init methods. Used by init_weights . Note Possible values are xavier_uniform , xavier_normal , kaiming_uniform and kaiming_normal","title":"InitMode"},{"location":"api/Quartznet/blocks/#thunder.quartznet.blocks.QuartznetBlock","text":"","title":"QuartznetBlock"},{"location":"api/Quartznet/blocks/#thunder.quartznet.blocks.QuartznetBlock.__init__","text":"Quartznet block. This is a refactoring of the Jasperblock present on the NeMo toolkit, but simplified to only support the new quartznet model. Biggest change is that dense residual used on Jasper is not supported here, and masked convolutions were also removed. Parameters: Name Type Description Default inplanes int Number of input planes required planes int Number of output planes required repeat int Repetitions inside block. 5 kernel_size List[int] Kernel size. [11] stride List[int] Stride of each repetition. [1] dilation List[int] Dilation of each repetition. [1] dropout float Dropout used before each activation. 0.0 residual bool Controls the use of residual connection. True separable bool Controls the use of separable convolutions. False Source code in thunder/quartznet/blocks.py def __init__ ( self , inplanes : int , planes : int , repeat : int = 5 , kernel_size : List [ int ] = [ 11 ], stride : List [ int ] = [ 1 ], dilation : List [ int ] = [ 1 ], dropout : float = 0.0 , residual : bool = True , separable : bool = False , ): \"\"\"Quartznet block. This is a refactoring of the Jasperblock present on the NeMo toolkit, but simplified to only support the new quartznet model. Biggest change is that dense residual used on Jasper is not supported here, and masked convolutions were also removed. Args: inplanes : Number of input planes planes : Number of output planes repeat : Repetitions inside block. kernel_size : Kernel size. stride : Stride of each repetition. dilation : Dilation of each repetition. dropout : Dropout used before each activation. residual : Controls the use of residual connection. separable : Controls the use of separable convolutions. \"\"\" super () . __init__ () padding_val = get_same_padding ( kernel_size [ 0 ], stride [ 0 ], dilation [ 0 ]) inplanes_loop = inplanes conv = [] for _ in range ( repeat - 1 ): conv . extend ( self . _get_conv_bn_layer ( inplanes_loop , planes , kernel_size = kernel_size , stride = stride , dilation = dilation , padding = padding_val , separable = separable , bias = False , ) ) conv . extend ( self . _get_act_dropout_layer ( drop_prob = dropout )) inplanes_loop = planes conv . extend ( self . _get_conv_bn_layer ( inplanes_loop , planes , kernel_size = kernel_size , stride = stride , dilation = dilation , padding = padding_val , separable = separable , bias = False , ) ) self . mconv = nn . Sequential ( * conv ) if residual : stride_residual = stride if stride [ 0 ] == 1 else stride [ 0 ] ** repeat self . res = nn . Sequential ( * self . _get_conv_bn_layer ( inplanes , planes , kernel_size = 1 , stride = stride_residual , bias = False , ) ) else : self . res = None self . mout = nn . Sequential ( * self . _get_act_dropout_layer ( drop_prob = dropout ))","title":"__init__()"},{"location":"api/Quartznet/blocks/#thunder.quartznet.blocks.QuartznetBlock.forward","text":"Parameters: Name Type Description Default x Tensor Tensor of shape (batch, features, time) where #features == inplanes required Returns: Type Description Tensor Result of applying the block on the input Source code in thunder/quartznet/blocks.py def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, features, time) where #features == inplanes Returns: Result of applying the block on the input \"\"\" # compute forward convolutions out = self . mconv ( x ) # compute the residuals if self . res is not None : res_out = self . res ( x ) out = out + res_out # compute the output out = self . mout ( out ) return out","title":"forward()"},{"location":"api/Quartznet/blocks/#thunder.quartznet.blocks.body","text":"Creates the body of the Quartznet model. That is the middle part. Parameters: Name Type Description Default filters List[int] List of filters inside each block in the body. required kernel_size List[int] Corresponding list of kernel sizes for each block. Should have the same length as the first argument. required repeat_blocks int Number of repetitions of each block inside the body. 1 Returns: Type Description List[thunder.quartznet.blocks.QuartznetBlock] List of layers that form the body of the network. Source code in thunder/quartznet/blocks.py def body ( filters : List [ int ], kernel_size : List [ int ], repeat_blocks : int = 1 ) -> List [ QuartznetBlock ]: \"\"\"Creates the body of the Quartznet model. That is the middle part. Args: filters : List of filters inside each block in the body. kernel_size : Corresponding list of kernel sizes for each block. Should have the same length as the first argument. repeat_blocks : Number of repetitions of each block inside the body. Returns: List of layers that form the body of the network. \"\"\" layers = [] f_in = 256 for f , k in zip ( filters , kernel_size ): for _ in range ( repeat_blocks ): layers . append ( QuartznetBlock ( f_in , f , kernel_size = [ k ], separable = True )) f_in = f layers . extend ( [ QuartznetBlock ( f_in , 512 , repeat = 1 , dilation = [ 2 ], kernel_size = [ 87 ], residual = False , separable = True , ), QuartznetBlock ( 512 , 1024 , repeat = 1 , kernel_size = [ 1 ], residual = False , separable = False ), ] ) return layers","title":"body()"},{"location":"api/Quartznet/blocks/#thunder.quartznet.blocks.get_same_padding","text":"Calculates the padding size to obtain same padding. Same padding means that the output will have the shape input_shape / stride. That means, for stride = 1 the output shape is the same as the input, and stride = 2 gives an output that is half of the input shape. Parameters: Name Type Description Default kernel_size int convolution kernel size. Only tested to be correct with odd values. required stride int convolution stride required dilation int convolution dilation required Exceptions: Type Description ValueError Only stride or dilation may be greater than 1 Returns: Type Description int padding value to obtain same padding. Source code in thunder/quartznet/blocks.py def get_same_padding ( kernel_size : int , stride : int , dilation : int ) -> int : \"\"\"Calculates the padding size to obtain same padding. Same padding means that the output will have the shape input_shape / stride. That means, for stride = 1 the output shape is the same as the input, and stride = 2 gives an output that is half of the input shape. Args: kernel_size : convolution kernel size. Only tested to be correct with odd values. stride : convolution stride dilation : convolution dilation Raises: ValueError: Only stride or dilation may be greater than 1 Returns: padding value to obtain same padding. \"\"\" if stride > 1 and dilation > 1 : raise ValueError ( \"Only stride OR dilation may be greater than 1\" ) if dilation > 1 : return ( dilation * ( kernel_size - 1 ) + 1 ) // 2 return kernel_size // 2","title":"get_same_padding()"},{"location":"api/Quartznet/blocks/#thunder.quartznet.blocks.init_weights","text":"Initialize Linear, MaskedConv1d/Conv1d or BatchNorm1d weights. There's no return, the operation occurs inplace. Parameters: Name Type Description Default m Module The layer to be initialized required mode InitMode Weight initialization mode. Only applicable to linear and conv layers. <InitMode.xavier_uniform: 'xavier_uniform'> Exceptions: Type Description ValueError Raised when the initial mode is not one of the possible options. Source code in thunder/quartznet/blocks.py def init_weights ( m : nn . Module , mode : InitMode = InitMode . xavier_uniform ): \"\"\"Initialize Linear, MaskedConv1d/Conv1d or BatchNorm1d weights. There's no return, the operation occurs inplace. Args: m: The layer to be initialized mode: Weight initialization mode. Only applicable to linear and conv layers. Raises: ValueError: Raised when the initial mode is not one of the possible options. \"\"\" if isinstance ( m , ( nn . Conv1d , nn . Linear )): if mode == InitMode . xavier_uniform : nn . init . xavier_uniform_ ( m . weight , gain = 1.0 ) elif mode == InitMode . xavier_normal : nn . init . xavier_normal_ ( m . weight , gain = 1.0 ) elif mode == InitMode . kaiming_uniform : nn . init . kaiming_uniform_ ( m . weight , nonlinearity = \"relu\" ) elif mode == InitMode . kaiming_normal : nn . init . kaiming_normal_ ( m . weight , nonlinearity = \"relu\" ) else : raise ValueError ( \"Unknown Initialization mode: {0} \" . format ( mode )) elif isinstance ( m , nn . BatchNorm1d ): if m . track_running_stats : m . running_mean . zero_ () m . running_var . fill_ ( 1 ) m . num_batches_tracked . zero_ () if m . affine : nn . init . ones_ ( m . weight ) nn . init . zeros_ ( m . bias )","title":"init_weights()"},{"location":"api/Quartznet/blocks/#thunder.quartznet.blocks.stem","text":"Creates the Quartznet stem. That is the first block of the model, that process the input directly. Parameters: Name Type Description Default feat_in int Number of input features required Returns: Type Description QuartznetBlock Quartznet stem block Source code in thunder/quartznet/blocks.py def stem ( feat_in : int ) -> QuartznetBlock : \"\"\"Creates the Quartznet stem. That is the first block of the model, that process the input directly. Args: feat_in : Number of input features Returns: Quartznet stem block \"\"\" return QuartznetBlock ( feat_in , 256 , repeat = 1 , kernel_size = [ 33 ], residual = False , separable = True )","title":"stem()"},{"location":"api/Quartznet/compatibility/","text":"Helper functions to load the Quartznet model from original Nemo released checkpoint files. get_quartznet ( name , checkpoint_folder = None ) Get quartznet model by identifier. This method downloads the checkpoint, creates the corresponding model and load the weights. Parameters: Name Type Description Default name str Model identifier. Check checkpoint_archives.keys() required checkpoint_folder str Folder where the checkpoint will be saved to. None Returns: Type Description Tuple[torch.nn.modules.module.Module, torch.nn.modules.module.Module] Encoder and decoder Modules with the checkpoint weights loaded Source code in thunder/quartznet/compatibility.py def get_quartznet ( name : str , checkpoint_folder : str = None ) -> Tuple [ nn . Module , nn . Module ]: \"\"\"Get quartznet model by identifier. This method downloads the checkpoint, creates the corresponding model and load the weights. Args: name: Model identifier. Check checkpoint_archives.keys() checkpoint_folder: Folder where the checkpoint will be saved to. Returns: Encoder and decoder Modules with the checkpoint weights loaded \"\"\" if checkpoint_folder is None : checkpoint_folder = Path . home () / \".thunder\" checkpoint_folder . mkdir ( exist_ok = True ) url = checkpoint_archives [ name ] filename = url . split ( \"/\" )[ - 1 ] checkpoint_path = Path ( checkpoint_folder ) / filename if not checkpoint_path . exists (): download_url ( url , download_folder = checkpoint_folder , resume = True , ) return load_from_nemo ( checkpoint_path ) load_from_nemo ( checkpoint_path ) Creates the model from the .nemo checkpoint file and load the weights. Parameters: Name Type Description Default checkpoint_path str Path to the .nemo checkpoint file required Returns: Type Description Tuple[torch.nn.modules.module.Module, torch.nn.modules.module.Module] Both encoder and decoder. Source code in thunder/quartznet/compatibility.py def load_from_nemo ( checkpoint_path : str ) -> Tuple [ nn . Module , nn . Module ]: \"\"\"Creates the model from the .nemo checkpoint file and load the weights. Args: checkpoint_path : Path to the .nemo checkpoint file Returns: Both encoder and decoder. \"\"\" with TemporaryDirectory () as extract_path : extract_path = Path ( extract_path ) extract_archive ( str ( checkpoint_path ), extract_path ) encoder , decoder = load_quartznet_weights ( extract_path / \"model_config.yaml\" , extract_path / \"model_weights.ckpt\" ) return encoder , decoder load_quartznet_weights ( config_path , weights_path ) Load quartznet/Quartznet model from data present inside .nemo file Parameters: Name Type Description Default config_path str Path to the .yaml configuration file. required weights_path str Path to the pytorch weights checkpoint required Returns: Type Description Tuple[torch.nn.modules.module.Module, torch.nn.modules.module.Module] Encoder and decoder Modules with the checkpoint weights loaded Source code in thunder/quartznet/compatibility.py def load_quartznet_weights ( config_path : str , weights_path : str ) -> Tuple [ nn . Module , nn . Module ]: \"\"\"Load quartznet/Quartznet model from data present inside .nemo file Args: config_path : Path to the .yaml configuration file. weights_path : Path to the pytorch weights checkpoint Returns: Encoder and decoder Modules with the checkpoint weights loaded \"\"\" encoder , decoder = read_config ( config_path ) weights = torch . load ( weights_path ) # We remove the 'encoder.' and 'decoder.' prefix from the weights to enable # compatibility to load with plain nn.Modules created by reading the config encoder_weights = { k . replace ( \"encoder.\" , \"\" ) . replace ( \".conv\" , \"\" ) . replace ( \".res.0\" , \".res\" ): v for k , v in weights . items () if \"encoder\" in k } encoder . load_state_dict ( encoder_weights , strict = True ) decoder_weights = { k . replace ( \"decoder.decoder_layers.\" , \"\" ): v for k , v in weights . items () if \"decoder\" in k } decoder . load_state_dict ( decoder_weights , strict = True ) return encoder , decoder read_config ( config_path ) Read .yaml config and creates the encoder and decoder modules Parameters: Name Type Description Default config_path str Hydra config describing the Quartznet model required Returns: Type Description Tuple[torch.nn.modules.module.Module, torch.nn.modules.module.Module] Encoder and decoder Modules randomly initializated Source code in thunder/quartznet/compatibility.py def read_config ( config_path : str ) -> Tuple [ nn . Module , nn . Module ]: \"\"\"Read .yaml config and creates the encoder and decoder modules Args: config_path: Hydra config describing the Quartznet model Returns: Encoder and decoder Modules randomly initializated \"\"\" conf = OmegaConf . load ( config_path ) encoder_params = conf [ \"encoder\" ][ \"params\" ] inplanes = encoder_params [ \"feat_in\" ] * encoder_params . get ( \"frame_splicing\" , 1 ) quartznet_conf = OmegaConf . to_container ( encoder_params [ \"jasper\" ]) layers = [] for cfg in quartznet_conf : cfg [ \"planes\" ] = cfg . pop ( \"filters\" ) cfg [ \"kernel_size\" ] = cfg . pop ( \"kernel\" ) layers . append ( QuartznetBlock ( inplanes = inplanes , ** cfg , ) ) inplanes = cfg [ \"planes\" ] encoder = nn . Sequential ( * layers ) encoder . apply ( init_weights ) decoder_params = conf [ \"decoder\" ][ \"params\" ] decoder = torch . nn . Sequential ( torch . nn . Conv1d ( decoder_params [ \"feat_in\" ], decoder_params [ \"num_classes\" ] + 1 , kernel_size = 1 , bias = True , ) ) decoder . apply ( init_weights ) return encoder , decoder","title":"Compatibility"},{"location":"api/Quartznet/compatibility/#thunder.quartznet.compatibility.get_quartznet","text":"Get quartznet model by identifier. This method downloads the checkpoint, creates the corresponding model and load the weights. Parameters: Name Type Description Default name str Model identifier. Check checkpoint_archives.keys() required checkpoint_folder str Folder where the checkpoint will be saved to. None Returns: Type Description Tuple[torch.nn.modules.module.Module, torch.nn.modules.module.Module] Encoder and decoder Modules with the checkpoint weights loaded Source code in thunder/quartznet/compatibility.py def get_quartznet ( name : str , checkpoint_folder : str = None ) -> Tuple [ nn . Module , nn . Module ]: \"\"\"Get quartznet model by identifier. This method downloads the checkpoint, creates the corresponding model and load the weights. Args: name: Model identifier. Check checkpoint_archives.keys() checkpoint_folder: Folder where the checkpoint will be saved to. Returns: Encoder and decoder Modules with the checkpoint weights loaded \"\"\" if checkpoint_folder is None : checkpoint_folder = Path . home () / \".thunder\" checkpoint_folder . mkdir ( exist_ok = True ) url = checkpoint_archives [ name ] filename = url . split ( \"/\" )[ - 1 ] checkpoint_path = Path ( checkpoint_folder ) / filename if not checkpoint_path . exists (): download_url ( url , download_folder = checkpoint_folder , resume = True , ) return load_from_nemo ( checkpoint_path )","title":"get_quartznet()"},{"location":"api/Quartznet/compatibility/#thunder.quartznet.compatibility.load_from_nemo","text":"Creates the model from the .nemo checkpoint file and load the weights. Parameters: Name Type Description Default checkpoint_path str Path to the .nemo checkpoint file required Returns: Type Description Tuple[torch.nn.modules.module.Module, torch.nn.modules.module.Module] Both encoder and decoder. Source code in thunder/quartznet/compatibility.py def load_from_nemo ( checkpoint_path : str ) -> Tuple [ nn . Module , nn . Module ]: \"\"\"Creates the model from the .nemo checkpoint file and load the weights. Args: checkpoint_path : Path to the .nemo checkpoint file Returns: Both encoder and decoder. \"\"\" with TemporaryDirectory () as extract_path : extract_path = Path ( extract_path ) extract_archive ( str ( checkpoint_path ), extract_path ) encoder , decoder = load_quartznet_weights ( extract_path / \"model_config.yaml\" , extract_path / \"model_weights.ckpt\" ) return encoder , decoder","title":"load_from_nemo()"},{"location":"api/Quartznet/compatibility/#thunder.quartznet.compatibility.load_quartznet_weights","text":"Load quartznet/Quartznet model from data present inside .nemo file Parameters: Name Type Description Default config_path str Path to the .yaml configuration file. required weights_path str Path to the pytorch weights checkpoint required Returns: Type Description Tuple[torch.nn.modules.module.Module, torch.nn.modules.module.Module] Encoder and decoder Modules with the checkpoint weights loaded Source code in thunder/quartznet/compatibility.py def load_quartznet_weights ( config_path : str , weights_path : str ) -> Tuple [ nn . Module , nn . Module ]: \"\"\"Load quartznet/Quartznet model from data present inside .nemo file Args: config_path : Path to the .yaml configuration file. weights_path : Path to the pytorch weights checkpoint Returns: Encoder and decoder Modules with the checkpoint weights loaded \"\"\" encoder , decoder = read_config ( config_path ) weights = torch . load ( weights_path ) # We remove the 'encoder.' and 'decoder.' prefix from the weights to enable # compatibility to load with plain nn.Modules created by reading the config encoder_weights = { k . replace ( \"encoder.\" , \"\" ) . replace ( \".conv\" , \"\" ) . replace ( \".res.0\" , \".res\" ): v for k , v in weights . items () if \"encoder\" in k } encoder . load_state_dict ( encoder_weights , strict = True ) decoder_weights = { k . replace ( \"decoder.decoder_layers.\" , \"\" ): v for k , v in weights . items () if \"decoder\" in k } decoder . load_state_dict ( decoder_weights , strict = True ) return encoder , decoder","title":"load_quartznet_weights()"},{"location":"api/Quartznet/compatibility/#thunder.quartznet.compatibility.read_config","text":"Read .yaml config and creates the encoder and decoder modules Parameters: Name Type Description Default config_path str Hydra config describing the Quartznet model required Returns: Type Description Tuple[torch.nn.modules.module.Module, torch.nn.modules.module.Module] Encoder and decoder Modules randomly initializated Source code in thunder/quartznet/compatibility.py def read_config ( config_path : str ) -> Tuple [ nn . Module , nn . Module ]: \"\"\"Read .yaml config and creates the encoder and decoder modules Args: config_path: Hydra config describing the Quartznet model Returns: Encoder and decoder Modules randomly initializated \"\"\" conf = OmegaConf . load ( config_path ) encoder_params = conf [ \"encoder\" ][ \"params\" ] inplanes = encoder_params [ \"feat_in\" ] * encoder_params . get ( \"frame_splicing\" , 1 ) quartznet_conf = OmegaConf . to_container ( encoder_params [ \"jasper\" ]) layers = [] for cfg in quartznet_conf : cfg [ \"planes\" ] = cfg . pop ( \"filters\" ) cfg [ \"kernel_size\" ] = cfg . pop ( \"kernel\" ) layers . append ( QuartznetBlock ( inplanes = inplanes , ** cfg , ) ) inplanes = cfg [ \"planes\" ] encoder = nn . Sequential ( * layers ) encoder . apply ( init_weights ) decoder_params = conf [ \"decoder\" ][ \"params\" ] decoder = torch . nn . Sequential ( torch . nn . Conv1d ( decoder_params [ \"feat_in\" ], decoder_params [ \"num_classes\" ] + 1 , kernel_size = 1 , bias = True , ) ) decoder . apply ( init_weights ) return encoder , decoder","title":"read_config()"},{"location":"api/Quartznet/model/","text":"Functionality to quickly create a new quartznet model. Quartznet15x5_encoder ( feat_in = 64 ) Build encoder corresponding to the Quartznet15x5 model. Parameters: Name Type Description Default feat_in int Number of input features to the model. 64 Returns: Type Description Module Pytorch model of the encoder Source code in thunder/quartznet/model.py def Quartznet15x5_encoder ( feat_in : int = 64 ) -> nn . Module : \"\"\"Build encoder corresponding to the Quartznet15x5 model. Args: feat_in : Number of input features to the model. Returns: Pytorch model of the encoder \"\"\" return Quartznet5 ( feat_in , repeat_blocks = 3 ) Quartznet5 ( feat_in , repeat_blocks = 1 ) Basic Quartznet encoder setup. Can be used to build either Quartznet5x5 or Quartznet15x5, Parameters: Name Type Description Default feat_in int Number of input features to the model. required repeat_blocks int Number of repetitions of each block. 1 Returns: Type Description Module Pytorch model corresponding to the encoder. Source code in thunder/quartznet/model.py def Quartznet5 ( feat_in : int , repeat_blocks : int = 1 ) -> nn . Module : \"\"\"Basic Quartznet encoder setup. Can be used to build either Quartznet5x5 or Quartznet15x5, Args: feat_in : Number of input features to the model. repeat_blocks : Number of repetitions of each block. Returns: Pytorch model corresponding to the encoder. \"\"\" filters = [ 256 , 256 , 512 , 512 , 512 ] kernel_sizes = [ 33 , 39 , 51 , 63 , 75 ] return nn . Sequential ( stem ( feat_in ), * body ( filters , kernel_sizes , repeat_blocks ), ) Quartznet5x5_encoder ( feat_in = 64 ) Build encoder corresponding to the Quartznet5x5 model. Parameters: Name Type Description Default feat_in int Number of input features to the model. 64 Returns: Type Description Module Pytorch model of the encoder Source code in thunder/quartznet/model.py def Quartznet5x5_encoder ( feat_in : int = 64 ) -> nn . Module : \"\"\"Build encoder corresponding to the Quartznet5x5 model. Args: feat_in : Number of input features to the model. Returns: Pytorch model of the encoder \"\"\" return Quartznet5 ( feat_in ) Quartznet_decoder ( num_classes ) Build the Quartznet decoder. Parameters: Name Type Description Default num_classes int Number of output classes of the model. It's the size of the vocabulary, excluding the blank symbol. required Returns: Type Description Module Pytorch model of the decoder Source code in thunder/quartznet/model.py def Quartznet_decoder ( num_classes : int ) -> nn . Module : \"\"\"Build the Quartznet decoder. Args: num_classes : Number of output classes of the model. It's the size of the vocabulary, excluding the blank symbol. Returns: Pytorch model of the decoder \"\"\" decoder = nn . Conv1d ( 1024 , num_classes + 1 , kernel_size = 1 , bias = True , ) decoder . apply ( init_weights ) return decoder","title":"Model"},{"location":"api/Quartznet/model/#thunder.quartznet.model.Quartznet15x5_encoder","text":"Build encoder corresponding to the Quartznet15x5 model. Parameters: Name Type Description Default feat_in int Number of input features to the model. 64 Returns: Type Description Module Pytorch model of the encoder Source code in thunder/quartznet/model.py def Quartznet15x5_encoder ( feat_in : int = 64 ) -> nn . Module : \"\"\"Build encoder corresponding to the Quartznet15x5 model. Args: feat_in : Number of input features to the model. Returns: Pytorch model of the encoder \"\"\" return Quartznet5 ( feat_in , repeat_blocks = 3 )","title":"Quartznet15x5_encoder()"},{"location":"api/Quartznet/model/#thunder.quartznet.model.Quartznet5","text":"Basic Quartznet encoder setup. Can be used to build either Quartznet5x5 or Quartznet15x5, Parameters: Name Type Description Default feat_in int Number of input features to the model. required repeat_blocks int Number of repetitions of each block. 1 Returns: Type Description Module Pytorch model corresponding to the encoder. Source code in thunder/quartznet/model.py def Quartznet5 ( feat_in : int , repeat_blocks : int = 1 ) -> nn . Module : \"\"\"Basic Quartznet encoder setup. Can be used to build either Quartznet5x5 or Quartznet15x5, Args: feat_in : Number of input features to the model. repeat_blocks : Number of repetitions of each block. Returns: Pytorch model corresponding to the encoder. \"\"\" filters = [ 256 , 256 , 512 , 512 , 512 ] kernel_sizes = [ 33 , 39 , 51 , 63 , 75 ] return nn . Sequential ( stem ( feat_in ), * body ( filters , kernel_sizes , repeat_blocks ), )","title":"Quartznet5()"},{"location":"api/Quartznet/model/#thunder.quartznet.model.Quartznet5x5_encoder","text":"Build encoder corresponding to the Quartznet5x5 model. Parameters: Name Type Description Default feat_in int Number of input features to the model. 64 Returns: Type Description Module Pytorch model of the encoder Source code in thunder/quartznet/model.py def Quartznet5x5_encoder ( feat_in : int = 64 ) -> nn . Module : \"\"\"Build encoder corresponding to the Quartznet5x5 model. Args: feat_in : Number of input features to the model. Returns: Pytorch model of the encoder \"\"\" return Quartznet5 ( feat_in )","title":"Quartznet5x5_encoder()"},{"location":"api/Quartznet/model/#thunder.quartznet.model.Quartznet_decoder","text":"Build the Quartznet decoder. Parameters: Name Type Description Default num_classes int Number of output classes of the model. It's the size of the vocabulary, excluding the blank symbol. required Returns: Type Description Module Pytorch model of the decoder Source code in thunder/quartznet/model.py def Quartznet_decoder ( num_classes : int ) -> nn . Module : \"\"\"Build the Quartznet decoder. Args: num_classes : Number of output classes of the model. It's the size of the vocabulary, excluding the blank symbol. Returns: Pytorch model of the decoder \"\"\" decoder = nn . Conv1d ( 1024 , num_classes + 1 , kernel_size = 1 , bias = True , ) decoder . apply ( init_weights ) return decoder","title":"Quartznet_decoder()"},{"location":"api/Quartznet/preprocess/","text":"Functionality to preprocess the audio input in the same way that the Quartznet model expects it. DitherAudio __init__ ( self , dither = 1e-05 ) special Add some dithering to the audio tensor. Note From wikipedia: Dither is an intentionally applied form of noise used to randomize quantization error. Parameters: Name Type Description Default dither float Amount of dither to add. 1e-05 Source code in thunder/quartznet/preprocess.py def __init__ ( self , dither : float = 1e-5 ): \"\"\"Add some dithering to the audio tensor. Note: From wikipedia: Dither is an intentionally applied form of noise used to randomize quantization error. Args: dither : Amount of dither to add. \"\"\" super () . __init__ () self . dither = dither forward ( self , x ) Parameters: Name Type Description Default x Tensor Tensor of shape (batch, time) required Source code in thunder/quartznet/preprocess.py @torch . no_grad () def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, time) \"\"\" if self . training : return x + self . dither * torch . randn_like ( x ) else : return x FeatureBatchNormalizer __init__ ( self ) special Normalize batch at the feature dimension. Source code in thunder/quartznet/preprocess.py def __init__ ( self ): \"\"\"Normalize batch at the feature dimension.\"\"\" super () . __init__ () self . div_guard = 1e-5 forward ( self , x ) Parameters: Name Type Description Default x Tensor Tensor of shape (batch, features, time) required Source code in thunder/quartznet/preprocess.py def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, features, time) \"\"\" x_mean = x . mean ( dim = 2 , keepdim = True ) . detach () x_std = x . std ( dim = 2 , keepdim = True ) . detach () # make sure x_std is not zero x_std += self . div_guard return ( x - x_mean ) / x_std MelScale __init__ ( self , sample_rate , n_fft , nfilt , log_scale = True ) special Convert a spectrogram to Mel scale, following the default formula of librosa instead of the one used by torchaudio. Also converts to log scale. Parameters: Name Type Description Default sample_rate int Sampling rate of the signal required n_fft int Number of fourier features required nfilt int Number of output mel filters to use required log_scale bool Controls if the output should also be applied a log scale. True Source code in thunder/quartznet/preprocess.py def __init__ ( self , sample_rate : int , n_fft : int , nfilt : int , log_scale : bool = True ): \"\"\"Convert a spectrogram to Mel scale, following the default formula of librosa instead of the one used by torchaudio. Also converts to log scale. Args: sample_rate : Sampling rate of the signal n_fft : Number of fourier features nfilt : Number of output mel filters to use log_scale : Controls if the output should also be applied a log scale. \"\"\" super () . __init__ () filterbanks = ( create_fb_matrix ( int ( 1 + n_fft // 2 ), n_mels = nfilt , sample_rate = sample_rate , f_min = 0 , f_max = sample_rate / 2 , norm = \"slaney\" , htk = True , ) . transpose ( 0 , 1 ) . unsqueeze ( 0 ) ) self . register_buffer ( \"fb\" , filterbanks ) self . log_scale = log_scale forward ( self , x ) Parameters: Name Type Description Default x Tensor Tensor of shape (batch, features, time) required Source code in thunder/quartznet/preprocess.py @torch . no_grad () def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, features, time) \"\"\" # dot with filterbank energies x = torch . matmul ( self . fb . to ( x . dtype ), x ) # log features # We want to avoid taking the log of zero if self . log_scale : x = torch . log ( x + 2 ** - 24 ) return x PowerSpectrum __init__ ( self , n_window_size = 320 , n_window_stride = 160 , n_fft = None ) special Calculates the power spectrum of the audio signal, following the same method as used in NEMO. Parameters: Name Type Description Default n_window_size int Number of elements in the window size. 320 n_window_stride int Number of elements in the window stride. 160 n_fft Optional[int] Number of fourier features. None Exceptions: Type Description ValueError Raised when incompatible parameters are passed. Source code in thunder/quartznet/preprocess.py def __init__ ( self , n_window_size : int = 320 , n_window_stride : int = 160 , n_fft : Optional [ int ] = None , ): \"\"\"Calculates the power spectrum of the audio signal, following the same method as used in NEMO. Args: n_window_size : Number of elements in the window size. n_window_stride : Number of elements in the window stride. n_fft : Number of fourier features. Raises: ValueError: Raised when incompatible parameters are passed. \"\"\" super () . __init__ () if n_window_size <= 0 or n_window_stride <= 0 : raise ValueError ( f \" { self } got an invalid value for either n_window_size or \" f \"n_window_stride. Both must be positive ints.\" ) self . win_length = n_window_size self . hop_length = n_window_stride self . n_fft = n_fft or 2 ** math . ceil ( math . log2 ( self . win_length )) window_tensor = torch . hann_window ( self . win_length , periodic = False ) self . register_buffer ( \"window\" , window_tensor ) forward ( self , x ) Parameters: Name Type Description Default x Tensor Tensor of shape (batch, time) required Source code in thunder/quartznet/preprocess.py @torch . no_grad () def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, time) \"\"\" x = torch . stft ( x , n_fft = self . n_fft , hop_length = self . hop_length , win_length = self . win_length , center = True , window = self . window . to ( dtype = torch . float ), return_complex = False , ) # torch returns real, imag; so convert to magnitude x = torch . sqrt ( x . pow ( 2 ) . sum ( - 1 )) # get power spectrum x = x . pow ( 2.0 ) return x PreEmphasisFilter __init__ ( self , preemph = 0.97 ) special Applies preemphasis filtering to the audio signal. This is a classic signal processing function to emphasise the high frequency portion of the content compared to the low frequency. It applies a FIR filter of the form: y[n] = y[n] - preemph * y[n-1] Parameters: Name Type Description Default preemph float Filter control factor. 0.97 Source code in thunder/quartznet/preprocess.py def __init__ ( self , preemph : float = 0.97 ): \"\"\"Applies preemphasis filtering to the audio signal. This is a classic signal processing function to emphasise the high frequency portion of the content compared to the low frequency. It applies a FIR filter of the form: `y[n] = y[n] - preemph * y[n-1]` Args: preemph : Filter control factor. \"\"\" super () . __init__ () self . preemph = preemph forward ( self , x ) Parameters: Name Type Description Default x Tensor Tensor of shape (batch, time) required Source code in thunder/quartznet/preprocess.py @torch . no_grad () def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, time) \"\"\" return torch . cat ( ( x [:, 0 ] . unsqueeze ( 1 ), x [:, 1 :] - self . preemph * x [:, : - 1 ]), dim = 1 ) FilterbankFeatures ( sample_rate = 16000 , n_window_size = 320 , n_window_stride = 160 , n_fft = 512 , preemph = 0.97 , nfilt = 64 , dither = 1e-05 , ** kwargs ) Creates the Filterbank features used in the Quartznet model. Parameters: Name Type Description Default sample_rate int Sampling rate of the signal 16000 n_window_size int Number of elements in the window size. 320 n_window_stride int Number of elements in the window stride. 160 n_fft int Number of fourier features. 512 preemph float Preemphasis filtering control factor. 0.97 nfilt int Number of output mel filters to use 64 dither float Amount of dither to add. 1e-05 Returns: Type Description Module Module that computes the features based on raw audio tensor. Source code in thunder/quartznet/preprocess.py def FilterbankFeatures ( sample_rate : int = 16000 , n_window_size : int = 320 , n_window_stride : int = 160 , n_fft : int = 512 , preemph : float = 0.97 , nfilt : int = 64 , dither : float = 1e-5 , ** kwargs , ) -> nn . Module : \"\"\"Creates the Filterbank features used in the Quartznet model. Args: sample_rate : Sampling rate of the signal n_window_size : Number of elements in the window size. n_window_stride : Number of elements in the window stride. n_fft : Number of fourier features. preemph : Preemphasis filtering control factor. nfilt : Number of output mel filters to use dither : Amount of dither to add. Returns: Module that computes the features based on raw audio tensor. \"\"\" return nn . Sequential ( DitherAudio ( dither = dither ), PreEmphasisFilter ( preemph = preemph ), PowerSpectrum ( n_window_size = n_window_size , n_window_stride = n_window_stride , n_fft = n_fft , ), MelScale ( sample_rate = sample_rate , n_fft = n_fft , nfilt = nfilt ), FeatureBatchNormalizer (), )","title":"Preprocess"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.DitherAudio","text":"","title":"DitherAudio"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.DitherAudio.__init__","text":"Add some dithering to the audio tensor. Note From wikipedia: Dither is an intentionally applied form of noise used to randomize quantization error. Parameters: Name Type Description Default dither float Amount of dither to add. 1e-05 Source code in thunder/quartznet/preprocess.py def __init__ ( self , dither : float = 1e-5 ): \"\"\"Add some dithering to the audio tensor. Note: From wikipedia: Dither is an intentionally applied form of noise used to randomize quantization error. Args: dither : Amount of dither to add. \"\"\" super () . __init__ () self . dither = dither","title":"__init__()"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.DitherAudio.forward","text":"Parameters: Name Type Description Default x Tensor Tensor of shape (batch, time) required Source code in thunder/quartznet/preprocess.py @torch . no_grad () def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, time) \"\"\" if self . training : return x + self . dither * torch . randn_like ( x ) else : return x","title":"forward()"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.FeatureBatchNormalizer","text":"","title":"FeatureBatchNormalizer"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.FeatureBatchNormalizer.__init__","text":"Normalize batch at the feature dimension. Source code in thunder/quartznet/preprocess.py def __init__ ( self ): \"\"\"Normalize batch at the feature dimension.\"\"\" super () . __init__ () self . div_guard = 1e-5","title":"__init__()"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.FeatureBatchNormalizer.forward","text":"Parameters: Name Type Description Default x Tensor Tensor of shape (batch, features, time) required Source code in thunder/quartznet/preprocess.py def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, features, time) \"\"\" x_mean = x . mean ( dim = 2 , keepdim = True ) . detach () x_std = x . std ( dim = 2 , keepdim = True ) . detach () # make sure x_std is not zero x_std += self . div_guard return ( x - x_mean ) / x_std","title":"forward()"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.MelScale","text":"","title":"MelScale"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.MelScale.__init__","text":"Convert a spectrogram to Mel scale, following the default formula of librosa instead of the one used by torchaudio. Also converts to log scale. Parameters: Name Type Description Default sample_rate int Sampling rate of the signal required n_fft int Number of fourier features required nfilt int Number of output mel filters to use required log_scale bool Controls if the output should also be applied a log scale. True Source code in thunder/quartznet/preprocess.py def __init__ ( self , sample_rate : int , n_fft : int , nfilt : int , log_scale : bool = True ): \"\"\"Convert a spectrogram to Mel scale, following the default formula of librosa instead of the one used by torchaudio. Also converts to log scale. Args: sample_rate : Sampling rate of the signal n_fft : Number of fourier features nfilt : Number of output mel filters to use log_scale : Controls if the output should also be applied a log scale. \"\"\" super () . __init__ () filterbanks = ( create_fb_matrix ( int ( 1 + n_fft // 2 ), n_mels = nfilt , sample_rate = sample_rate , f_min = 0 , f_max = sample_rate / 2 , norm = \"slaney\" , htk = True , ) . transpose ( 0 , 1 ) . unsqueeze ( 0 ) ) self . register_buffer ( \"fb\" , filterbanks ) self . log_scale = log_scale","title":"__init__()"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.MelScale.forward","text":"Parameters: Name Type Description Default x Tensor Tensor of shape (batch, features, time) required Source code in thunder/quartznet/preprocess.py @torch . no_grad () def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, features, time) \"\"\" # dot with filterbank energies x = torch . matmul ( self . fb . to ( x . dtype ), x ) # log features # We want to avoid taking the log of zero if self . log_scale : x = torch . log ( x + 2 ** - 24 ) return x","title":"forward()"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.PowerSpectrum","text":"","title":"PowerSpectrum"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.PowerSpectrum.__init__","text":"Calculates the power spectrum of the audio signal, following the same method as used in NEMO. Parameters: Name Type Description Default n_window_size int Number of elements in the window size. 320 n_window_stride int Number of elements in the window stride. 160 n_fft Optional[int] Number of fourier features. None Exceptions: Type Description ValueError Raised when incompatible parameters are passed. Source code in thunder/quartznet/preprocess.py def __init__ ( self , n_window_size : int = 320 , n_window_stride : int = 160 , n_fft : Optional [ int ] = None , ): \"\"\"Calculates the power spectrum of the audio signal, following the same method as used in NEMO. Args: n_window_size : Number of elements in the window size. n_window_stride : Number of elements in the window stride. n_fft : Number of fourier features. Raises: ValueError: Raised when incompatible parameters are passed. \"\"\" super () . __init__ () if n_window_size <= 0 or n_window_stride <= 0 : raise ValueError ( f \" { self } got an invalid value for either n_window_size or \" f \"n_window_stride. Both must be positive ints.\" ) self . win_length = n_window_size self . hop_length = n_window_stride self . n_fft = n_fft or 2 ** math . ceil ( math . log2 ( self . win_length )) window_tensor = torch . hann_window ( self . win_length , periodic = False ) self . register_buffer ( \"window\" , window_tensor )","title":"__init__()"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.PowerSpectrum.forward","text":"Parameters: Name Type Description Default x Tensor Tensor of shape (batch, time) required Source code in thunder/quartznet/preprocess.py @torch . no_grad () def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, time) \"\"\" x = torch . stft ( x , n_fft = self . n_fft , hop_length = self . hop_length , win_length = self . win_length , center = True , window = self . window . to ( dtype = torch . float ), return_complex = False , ) # torch returns real, imag; so convert to magnitude x = torch . sqrt ( x . pow ( 2 ) . sum ( - 1 )) # get power spectrum x = x . pow ( 2.0 ) return x","title":"forward()"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.PreEmphasisFilter","text":"","title":"PreEmphasisFilter"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.PreEmphasisFilter.__init__","text":"Applies preemphasis filtering to the audio signal. This is a classic signal processing function to emphasise the high frequency portion of the content compared to the low frequency. It applies a FIR filter of the form: y[n] = y[n] - preemph * y[n-1] Parameters: Name Type Description Default preemph float Filter control factor. 0.97 Source code in thunder/quartznet/preprocess.py def __init__ ( self , preemph : float = 0.97 ): \"\"\"Applies preemphasis filtering to the audio signal. This is a classic signal processing function to emphasise the high frequency portion of the content compared to the low frequency. It applies a FIR filter of the form: `y[n] = y[n] - preemph * y[n-1]` Args: preemph : Filter control factor. \"\"\" super () . __init__ () self . preemph = preemph","title":"__init__()"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.PreEmphasisFilter.forward","text":"Parameters: Name Type Description Default x Tensor Tensor of shape (batch, time) required Source code in thunder/quartznet/preprocess.py @torch . no_grad () def forward ( self , x : torch . Tensor ) -> torch . Tensor : \"\"\" Args: x : Tensor of shape (batch, time) \"\"\" return torch . cat ( ( x [:, 0 ] . unsqueeze ( 1 ), x [:, 1 :] - self . preemph * x [:, : - 1 ]), dim = 1 )","title":"forward()"},{"location":"api/Quartznet/preprocess/#thunder.quartznet.preprocess.FilterbankFeatures","text":"Creates the Filterbank features used in the Quartznet model. Parameters: Name Type Description Default sample_rate int Sampling rate of the signal 16000 n_window_size int Number of elements in the window size. 320 n_window_stride int Number of elements in the window stride. 160 n_fft int Number of fourier features. 512 preemph float Preemphasis filtering control factor. 0.97 nfilt int Number of output mel filters to use 64 dither float Amount of dither to add. 1e-05 Returns: Type Description Module Module that computes the features based on raw audio tensor. Source code in thunder/quartznet/preprocess.py def FilterbankFeatures ( sample_rate : int = 16000 , n_window_size : int = 320 , n_window_stride : int = 160 , n_fft : int = 512 , preemph : float = 0.97 , nfilt : int = 64 , dither : float = 1e-5 , ** kwargs , ) -> nn . Module : \"\"\"Creates the Filterbank features used in the Quartznet model. Args: sample_rate : Sampling rate of the signal n_window_size : Number of elements in the window size. n_window_stride : Number of elements in the window stride. n_fft : Number of fourier features. preemph : Preemphasis filtering control factor. nfilt : Number of output mel filters to use dither : Amount of dither to add. Returns: Module that computes the features based on raw audio tensor. \"\"\" return nn . Sequential ( DitherAudio ( dither = dither ), PreEmphasisFilter ( preemph = preemph ), PowerSpectrum ( n_window_size = n_window_size , n_window_stride = n_window_stride , n_fft = n_fft , ), MelScale ( sample_rate = sample_rate , n_fft = n_fft , nfilt = nfilt ), FeatureBatchNormalizer (), )","title":"FilterbankFeatures()"}]}